
/**
* AUTOGENERATED BY convert.py
* DO NOT EDIT THIS FILE!
*
* IF MODIFICATIONS NEED TO BE MADE, MODIFY can_data.txt!
*
* CAN Defintiion for ECU 'ANY_ECU'
*/

#ifndef __ECU_ECU_CAR_H_
#define __ECU_ECU_CAR_H_

#include <stdint.h>

#define EMS11_CAN_ID 0x0316
#define CLU2_CAN_ID 0x0690
#define CLU1_CAN_ID 0x04F0
#define TCU2_CAN_ID 0x0440
#define EMS14_CAN_ID 0x0545
#define SAS11_CAN_ID 0x02B0
#define FATC_CAN_ID 0x0350
#define DATC12_CAN_ID 0x0042

/** Number of ASA alert */
enum class MS_ANZ_ASS_WARN_EGS52 : uint16_t {
	IDLE = 0, // No status / warning
	M1 = 1, // Message "ASA inactive: warming up the engine"
	M2 = 2, // Message "ASA Active driving"
	M3 = 3, // Message "ASA Active stop mode"
	M4 = 4, // Message "ASA switched off: electrical power supplies"
	M5 = 5, // Message "ASA switched off: air conditioner"
	M6 = 6, // Message "ASA not active: Fault"
	M7 = 7, // Message "ASA Active electrical energy demand, Please start engine"
	M8 = 8, // Message "ASA active: For starting clutch kick"
	M9 = 9, // Message "ASA active: Air start Please Motor"
	M10 = 10, // Message "ASA Active: When leaving ignition off!"
	M11 = 11, // Message "ASA disabled"
	M12 = 12, // Message "ASA activated"
	M13 = 13, // Message "ASA: Display defective"
	M14 = 14, // not defined
	M15 = 15, // not defined
};

typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		uint32_t __PADDING__: 32;
		uint16_t RPM: 16;
		uint8_t __PADDING1__: 8;
		bool SWI_IGK: 1;
		bool F_N_ENG: 1;
		uint8_t __PADDING2__: 6;
	} __attribute__((packed));
	uint32_t get_canid(){ return EMS11_CAN_ID; }
} EMS11_CAN;

typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		uint32_t __PADDING__: 32;
		uint32_t __PADDING1__: 24;
		uint8_t CF_Clu_IGNSw: 3;
		uint8_t __PADDING3__: 5;
	} __attribute__((packed));
	uint32_t get_canid(){ return CLU2_CAN_ID; }
} CLU2_CAN;

typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
        uint32_t CF_Clu_Odometer: 24;
        uint32_t __PADDING__: 32;
        bool CF_Clu_ParkBrakeSw: 1;
	} __attribute__((packed));
	uint32_t get_canid(){ return CLU1_CAN_ID; }
} CLU1_CAN;

typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
        uint32_t __PADDING__: 20;
		uint32_t __PADDING1__: 32;
        uint32_t CUR_GR: 4;
	} __attribute__((packed));
	uint32_t get_canid(){ return TCU2_CAN_ID; }
} TCU2_CAN;

typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		uint32_t __PADDING__:32;
		uint8_t __PADDING1__: 8;
		uint8_t VB: 8;
	} __attribute__((packed));
	uint32_t get_canid(){ return EMS14_CAN_ID; }
} EMS14_CAN;

typedef union {
	uint64_t raw;
	uint8_t bytes[8];
	struct {
		uint32_t __PADDING__: 32;
		uint16_t __PADDING1__: 16;
		uint16_t SAS_ANGLE: 16;
	} __attribute__((packed));
	uint32_t get_canid(){ return SAS11_CAN_ID; }
} SAS11_CAN;

typedef union {
	uint64_t raw;
	uint8_t bytes[8]; // 5
	struct {
		uint32_t __PADDING__: 32;
		uint8_t CR_Fatc_OutTemp: 8;
	} __attribute__((packed));
	uint32_t get_canid(){ return FATC_CAN_ID; }
} FATC_CAN;

typedef union {
	uint64_t raw;
	uint8_t bytes[8]; // 5
	struct {
		uint32_t __PADDING__: 32;
		uint32_t __PADDING1__: 24;
		uint8_t CR_Datc_DrTempDispC: 8;
	} __attribute__((packed));
	uint32_t get_canid(){ return DATC12_CAN_ID; }
} DATC12_CAN;



class ECU_JERRY {
	public:
        /**
         * @brief Imports the CAN frame given the CAN ID, CAN Contents, and current timestamp
         *
         * Returns true if the frame was imported successfully, and false if import failed (Due to non-matching CAN ID).
         *
         * NOTE: The endianness of the value cannot be guaranteed. It is up to the caller to correct the byte order!
         */
        bool import_frames(uint64_t value, uint32_t can_id, uint64_t timestamp_now) {
            uint8_t idx = 0;
            bool add = true;
            switch(can_id) {
                // case ARCADE_A2_EGS52_CAN_ID:
				case EMS11_CAN_ID:
                    idx = 0;
                    break;
                case CLU2_CAN_ID:
                    idx = 1;
                    break;
                case EMS14_CAN_ID:
                    idx = 2;
                    break;
                case SAS11_CAN_ID:
                    idx = 3;
                    break;
				case CLU1_CAN_ID:
                    idx = 4;
                    break;
				case FATC_CAN_ID:
                    idx = 5;
                    break;
				case DATC12_CAN_ID:
                    idx = 6;
                    break;
                default:
                    add = false;
                    break;
            }
            if (add) {
                LAST_FRAME_TIMES[idx] = timestamp_now;
                FRAME_DATA[idx] = value;
            }
            return add;
        }
        
		bool GET_DATC12_DATA(uint64_t now, uint64_t max_expire_time, DATC12_CAN* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[6] <= now && now - LAST_FRAME_TIMES[6] < max_expire_time) {
                dest->raw = FRAME_DATA[6];
                ret = true;
            }
            return ret;
        }

		bool GET_FATC_DATA(uint64_t now, uint64_t max_expire_time, FATC_CAN* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[5] <= now && now - LAST_FRAME_TIMES[5] < max_expire_time) {
                dest->raw = FRAME_DATA[5];
                ret = true;
            }
            return ret;
        }

		bool GET_CLU1_DATA(uint64_t now, uint64_t max_expire_time, CLU1_CAN* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[4] <= now && now - LAST_FRAME_TIMES[4] < max_expire_time) {
                dest->raw = FRAME_DATA[4];
                ret = true;
            }
            return ret;
        }

        bool GET_SAS11_DATA(uint64_t now, uint64_t max_expire_time, SAS11_CAN* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[3] <= now && now - LAST_FRAME_TIMES[3] < max_expire_time) {
                dest->raw = FRAME_DATA[3];
                ret = true;
            }
            return ret;
        }

		bool GET_EMS14_DATA(uint64_t now, uint64_t max_expire_time, EMS14_CAN* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[2] <= now && now - LAST_FRAME_TIMES[2] < max_expire_time) {
                dest->raw = FRAME_DATA[2];
                ret = true;
            }
            return ret;
        }
		
		bool GET_CLU2_DATA(uint64_t now, uint64_t max_expire_time, CLU2_CAN* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[1] <= now && now - LAST_FRAME_TIMES[1] < max_expire_time) {
                dest->raw = FRAME_DATA[1];
                ret = true;
            }
            return ret;
        }

        bool GET_EMS11_DATA(uint64_t now, uint64_t max_expire_time, EMS11_CAN* dest) const {
            bool ret = false;
            if (dest != nullptr && LAST_FRAME_TIMES[0] <= now && now - LAST_FRAME_TIMES[0] < max_expire_time) {
                dest->raw = FRAME_DATA[0];
                ret = true;
            }
            return ret;
        }		
            
	private:
		uint64_t FRAME_DATA[10];
		uint64_t LAST_FRAME_TIMES[10];
};
#endif // __ECU_ECU_CAR_H_